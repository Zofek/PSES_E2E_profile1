        -:    0:Source:E2E_profile1.c
        -:    0:Graph:UT_E2E_profile1.gcno
        -:    0:Data:UT_E2E_profile1.gcda
        -:    0:Runs:6
        -:    1:#include "..\inc\Std_Types.h"
        -:    2:#include "..\inc\crc.h"
        -:    3:#include "..\inc\E2E_profile1.h"
        -:    4:
        -:    5:#define E2E_P01_DATAID_BOTH 0x0
        -:    6:#define E2E_P01_DATAID_ALT 0x1
        -:    7:#define E2E_P01_DATAID_LOW 0x2
        -:    8:#define E2E_P01_DATAID_NIBBLE 0x3
        -:    9:
        -:   10:#define MAX_P01_DATA_LENGTH_IN_BITS    (240)
        -:   11:#define MAX_P01_COUNTER_VALUE          (14)
        -:   12:
    #####:   13:uint8 E2E_UpdateCounter(uint8 Counter) {
    #####:   14:    return (Counter+1) % 15; /* Use the Profile 1 value */
        -:   15:}
        -:   16:
        -:   17:/*Creation of the E2E header*/
        -:   18:/*--------------------------------------------------------------------------------------------*/
        -:   19:/*--------------------------------------------------------------------------------------------*/
    #####:   20:static uint8 CalculateDeltaCounter(uint8 receivedCounter, uint8 lastValidCounter)
        -:   21:{
    #####:   22:    if (receivedCounter >= lastValidCounter) {
    #####:   23:        return receivedCounter - lastValidCounter;
        -:   24:    }
        -:   25:    else {
    #####:   26:        return MAX_P01_COUNTER_VALUE + 1 + receivedCounter - lastValidCounter;
        -:   27:    }
        -:   28:}
        -:   29:
        4:   30:static Std_ReturnType CheckConfig(E2E_P01ConfigType* Config) 
        -:   31:{
        -:   32:
        -:   33:    /* Check for NULL pointers */
        4:   34:    if (Config == NULL) {
    #####:   35:        return E2E_E_INPUTERR_NULL; /* MISRA exception */
        -:   36:    }
        -:   37:
        -:   38:    /* Check input parameters values */
       4*:   39:    if ((Config->DataLength > MAX_P01_DATA_LENGTH_IN_BITS) || (Config->DataLength % 8 != 0)  ||
    #####:   40:        (Config->CounterOffset % 4 != 0) || Config->CRCOffset % 8 != 0) {
        4:   41:        return E2E_E_INPUTERR_WRONG; /* MISRA exception */
        -:   42:    }
        -:   43:
        -:   44:    /* Check that input parameters do not overlap and fits into the data array. It is enough to
        -:   45:     * check if the CRC and Counter are in the same byte since the CRC is one byte long */
    #####:   46:    if ((Config->CRCOffset + 8 > Config->DataLength) || (Config->CounterOffset + 4 > Config->DataLength) ||
    #####:   47:        (Config->CRCOffset/8 == Config->CounterOffset/8)) {
    #####:   48:        return E2E_E_INPUTERR_WRONG; /* MISRA exception */
        -:   49:    }
        -:   50:
    #####:   51:    return E2E_E_OK;
        -:   52:	
        -:   53:}
        -:   54:
        -:   55:
        -:   56:/*------------------------------------------------------------------------------*/
        -:   57:/*
        -:   58:[PRS_E2E_00163]
        -:   59:[PRS_E2E_00085]
        -:   60:[PRS_E2E_00085]
        -:   61:[PRS_E2E_00306]
        -:   62:[PRS_E2E_00190]
        -:   63:[PRS_E2E_00082]
        -:   64:[PRS_E2E_00640]
        -:   65:*/
        -:   66:
    #####:   67:static uint8 compute_p01_crc(E2E_P01ConfigType* Config, uint8 Counter, uint8* Data)
        -:   68:{
    #####:   69:    uint8 crc = 0x00;
    #####:   70:    uint8 lowerByteId = (uint8)Config->DataID;
    #####:   71:    uint8 upperByteId = (uint8)(Config->DataID>>8);
        -:   72:
        -:   73:    /* Calculate CRC on the Data ID */
    #####:   74:    if (Config->DataIDMode == E2E_P01_DATAID_BOTH)
        -:   75:    {
    #####:   76:        crc = Crc_CalculateCRC8(&lowerByteId, 1, crc, FALSE);
    #####:   77:        crc = Crc_CalculateCRC8(&upperByteId, 1, crc ^ CRC8_XOR_VALUE, FALSE);
        -:   78:    }
    #####:   79:    else if (Config->DataIDMode == E2E_P01_DATAID_LOW)
        -:   80:    {
    #####:   81:        crc = Crc_CalculateCRC8(&lowerByteId, 1, crc, FALSE);
        -:   82:    }
    #####:   83:    else if (Counter % 2 == 0)
        -:   84:    {
    #####:   85:        crc = Crc_CalculateCRC8(&lowerByteId, 1, crc, FALSE);
        -:   86:    }
        -:   87:    else
        -:   88:    {
    #####:   89:        crc = Crc_CalculateCRC8(&upperByteId, 1, crc, FALSE);
        -:   90:    }
        -:   91:
        -:   92:
        -:   93:    /* Calculate CRC on the data */
    #####:   94:    if (Config->CRCOffset >= 8) {
    #####:   95:        crc = Crc_CalculateCRC8 (Data, (Config->CRCOffset / 8), crc ^ CRC8_XOR_VALUE, FALSE);
        -:   96:    }
        -:   97:
    #####:   98:    if (Config->CRCOffset / 8 < (Config->DataLength / 8) - 1) {
    #####:   99:        crc = Crc_CalculateCRC8 (&Data[Config->CRCOffset/8 + 1],
    #####:  100:                                (Config->DataLength / 8 - Config->CRCOffset / 8 - 1),
        -:  101:                                crc ^ CRC8_XOR_VALUE, FALSE);
        -:  102:    }
        -:  103:
    #####:  104:    return crc ^ CRC8_XOR_VALUE;
        -:  105:
        -:  106:}
        -:  107:
        -:  108:
        2:  109:Std_ReturnType E2E_P01Protect(E2E_P01ConfigType* Config, E2E_P01SenderStateType* State, uint8* Data) 
        -:  110:{
        -:  111:
        2:  112:    Std_ReturnType returnValue = CheckConfig(Config);
        -:  113:
        2:  114:    if (E2E_E_OK != returnValue) {
        2:  115:        return returnValue;
        -:  116:    }
        -:  117:
    #####:  118:    if ((State == NULL) || (Data == NULL)) {
    #####:  119:        return E2E_E_INPUTERR_NULL; /* MISRA exception */
        -:  120:    }
        -:  121:
        -:  122:    /* Put counter in data*/
    #####:  123:    if (Config->CounterOffset % 8 == 0) {
    #####:  124:        *(Data+(Config->CounterOffset/8)) = (*(Data+(Config->CounterOffset/8)) & 0xF0) | (State->Counter & 0x0F);
        -:  125:    }
        -:  126:    else {
    #####:  127:        *(Data+(Config->CounterOffset/8)) = (*(Data+(Config->CounterOffset/8)) & 0x0F) | ((State->Counter<<4) & 0xF0);
        -:  128:    }
        -:  129:
        -:  130:    /* Calculate CRC */
    #####:  131:    *(Data+(Config->CRCOffset/8)) = compute_p01_crc(Config, State->Counter, Data);
        -:  132:
        -:  133:    /* Update counter */
    #####:  134:    State->Counter = E2E_UpdateCounter(State->Counter);
        -:  135:
    #####:  136:    return E2E_E_OK;
        -:  137:}
        -:  138:/*--------------------------------------------------------------------------------------------*/
        -:  139:/*--------------------------------------------------------------------------------------------*/
        -:  140:
        -:  141:
        -:  142:
        -:  143:
        -:  144:/*Evaluation of E2E- Header*/
        -:  145:/*--------------------------------------------------------------------------------------------*/
        -:  146:/*--------------------------------------------------------------------------------------------*/
        -:  147:
        2:  148:Std_ReturnType E2E_P01Check(E2E_P01ConfigType* Config, E2E_P01ReceiverStateType* State, uint8* Data) 
        -:  149:{
        -:  150:
        2:  151:    uint8 receivedCounter = 0;
        2:  152:    uint8 receivedCrc = 0;
        2:  153:    uint8 calculatedCrc = 0;
        2:  154:    uint8 delta = 0;
        2:  155:    Std_ReturnType returnValue = CheckConfig(Config);
        -:  156:
        2:  157:    if (E2E_E_OK != returnValue) {
        2:  158:        return returnValue;
        -:  159:    }
        -:  160:
    #####:  161:    if ((State == NULL) || (Data == NULL)) {
    #####:  162:        return E2E_E_INPUTERR_NULL; /* MISRA exception */
        -:  163:    }
        -:  164:
        -:  165:    /* This is the stated behavior in figure 7-6 but it seems wrong. This means that if more than 15
        -:  166:     * messages are received with wrong CRC, the first message with correct CRC will be have state
        -:  167:     * OKSOMELOST even though it should be WRONGSEQUENCE.
        -:  168:     */
    #####:  169:    if (State->MaxDeltaCounter < MAX_P01_COUNTER_VALUE) {
    #####:  170:        State->MaxDeltaCounter++;
        -:  171:    }
        -:  172:
    #####:  173:    if (State->NewDataAvailable == FALSE) {
    #####:  174:        State->Status = E2E_P01STATUS_NONEWDATA;
    #####:  175:        return E2E_E_OK;  /* MISRA exception */
        -:  176:    }
        -:  177:
        -:  178:    /* Counter offset is 4-bit aligned, this check is used to find out if high or low nibble */
    #####:  179:    if (Config->CounterOffset % 8 == 0) {
    #####:  180:        receivedCounter = *(Data+(Config->CounterOffset/8)) & 0x0F;
        -:  181:    }
        -:  182:    else {
    #####:  183:        receivedCounter = (*(Data+(Config->CounterOffset/8)) >> 4) & 0x0F;
        -:  184:    }
        -:  185:
    #####:  186:    receivedCrc = *(Data+(Config->CRCOffset/8));
    #####:  187:    calculatedCrc = compute_p01_crc(Config, receivedCounter, Data);
        -:  188:
    #####:  189:    if (receivedCrc != calculatedCrc) {
    #####:  190:        State->Status = E2E_P01STATUS_WRONGCRC;
    #####:  191:        return E2E_E_OK;
        -:  192:    }
        -:  193:
        -:  194:    /* Check if this is the first data since initialization */
    #####:  195:    if (State->WaitForFirstData == TRUE) {
    #####:  196:        State->WaitForFirstData = FALSE;
    #####:  197:        State->MaxDeltaCounter = Config->MaxDeltaCounterInit;
    #####:  198:        State->LastValidCounter = receivedCounter;
    #####:  199:        State->Status= E2E_P01STATUS_INITAL;
    #####:  200:        return E2E_E_OK;
        -:  201:    }
        -:  202:
        -:  203:    /* Ok, this is the normal case. Check the counter delta */
    #####:  204:    delta = CalculateDeltaCounter(receivedCounter, State->LastValidCounter);
        -:  205:
    #####:  206:    if (delta == 1) {
    #####:  207:        State->MaxDeltaCounter = Config->MaxDeltaCounterInit;
    #####:  208:        State->LastValidCounter = receivedCounter;
    #####:  209:        State->LostData = 0;
    #####:  210:        State->Status= E2E_P01STATUS_OK;
        -:  211:    }
    #####:  212:    else if (delta == 0) {
    #####:  213:        State->Status= E2E_P01STATUS_REPEATED;
        -:  214:    }
    #####:  215:    else if (delta <= State->MaxDeltaCounter) {
    #####:  216:        State->MaxDeltaCounter = Config->MaxDeltaCounterInit;
    #####:  217:        State->LastValidCounter = receivedCounter;
    #####:  218:        State->LostData = delta - 1;
    #####:  219:        State->Status= E2E_P01STATUS_OKSOMELOST;
        -:  220:    }
        -:  221:    else {
    #####:  222:        State->Status= E2E_P01STATUS_WRONGSEQUENCE;
        -:  223:    }
        -:  224:
    #####:  225:    return E2E_E_OK;
        -:  226:}
        -:  227:/*--------------------------------------------------------------------------------------------*/
        -:  228:/*--------------------------------------------------------------------------------------------*/
